trigger:
  branches:
    include:
      - master
      - develop

pool: 'TBS Self Hosted'

variables:
  buildConfiguration: 'Release'
  solution: '**/*.sln'
  outputDir: '$(Build.ArtifactStagingDirectory)/nuget'
  nugetSource: 'TBS_Custom_Feed'
  componentsProject: 'GCFoundation.Components/CGFoundation.Components.csproj'
  commonProject: 'GCFoundation.Common/GCFoundation.Common.csproj'
  securityProject: 'GCFoundation.Security/GCFoundation.Security.csproj'

  isMain: $[eq(variables['Build.SourceBranchName'], 'master')]
  versionSuffix: $[iif(eq(variables['isMain'], 'True'), '', '-beta')]


name: 1.0.$(Date:yyyyMMdd)$(Rev:.r)$(versionSuffix)

stages:
- stage: Build
  displayName: 'Build and Package'
  jobs:
  - job: BuildMatrix
    displayName: 'Build Projects in Parallel'
    strategy:
      matrix:
        Common:
          projectPath: 'GCFoundation.Common/GCFoundation.Common.csproj'
          projectName: 'GCFoundation.Common'
        Components:
          projectPath: 'GCFoundation.Components/CGFoundation.Components.csproj'
          projectName: 'GCFoundation.Components'
        Security:
          projectPath: 'GCFoundation.Security/GCFoundation.Security.csproj'
          projectName: 'GCFoundation.Security'
      maxParallel: 3
    
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '8.x'

    - task: UseNode@1
      inputs:
        version: '22.x'
      displayName: 'Install Node.js'

    - task: NuGetToolInstaller@1
      displayName: 'NuGet Tool Installer'

    - task: NuGetCommand@2
      displayName: 'Restore NuGet Packages'
      inputs:
        restoreSolution: '$(solution)'

    # Install NPM packages for Foundation.Components (only for Components build)
    - task: Npm@1
      displayName: 'Install NPM packages for Foundation.Components'
      condition: eq(variables['projectName'], 'GCFoundation.Components')
      inputs:
        command: 'install'
        workingDir: 'GCFoundation.Components'

    # Build the specific project
    - task: DotNetCoreCLI@2
      displayName: 'Build $(projectName)'
      inputs:
        command: 'build'
        projects: '$(projectPath)'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    # Pack the project (only for non-PR builds)
    - task: DotNetCoreCLI@2
      displayName: 'Pack $(projectName)'
      condition: ne(variables['Build.Reason'], 'PullRequest')
      inputs:
        command: 'pack'
        packagesToPack: '$(projectPath)'
        configuration: '$(buildConfiguration)'
        outputDir: '$(outputDir)'
        nobuild: true
        versioningScheme: byBuildNumber

    # Publish build artifacts for each project
    - task: PublishBuildArtifacts@1
      displayName: 'Publish $(projectName) Artifacts'
      condition: ne(variables['Build.Reason'], 'PullRequest')
      inputs:
        pathToPublish: '$(outputDir)'
        artifactName: '$(projectName)-packages'
        artifactType: 'container'

- stage: Security
  displayName: 'Advanced Security Scanning'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: SecurityAnalysis
    displayName: 'Comprehensive Security Analysis'
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '8.x'

    - task: NuGetCommand@2
      displayName: 'Restore NuGet Packages'
      inputs:
        restoreSolution: '$(solution)'

    # Install security analysis tools
    - task: PowerShell@2
      displayName: 'Install Security Tools'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "## Installing Security Analysis Tools" -ForegroundColor Cyan
          
          # Install .NET security tools
          try {
            dotnet tool install --global dotnet-audit
            Write-Host "‚úÖ dotnet-audit installed" -ForegroundColor Green
          } catch {
            Write-Host "‚ö†Ô∏è dotnet-audit installation failed" -ForegroundColor Yellow
          }
          
          try {
            dotnet tool install --global security-scan
            Write-Host "‚úÖ security-scan installed" -ForegroundColor Green
          } catch {
            Write-Host "‚ö†Ô∏è security-scan installation failed" -ForegroundColor Yellow
          }

    # OWASP Dependency Check
    - task: PowerShell@2
      displayName: 'OWASP Dependency Check'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "## OWASP Dependency Check" -ForegroundColor Cyan
          Write-Host "Downloading OWASP Dependency Check..." -ForegroundColor Yellow
          
          try {
            # Download OWASP Dependency Check
            $version = "8.4.0"
            $url = "https://github.com/jeremylong/DependencyCheck/releases/download/v$version/dependency-check-$version-release.zip"
            Invoke-WebRequest -Uri $url -OutFile "dependency-check.zip" -UseBasicParsing
            
            # Extract and run
            Expand-Archive "dependency-check.zip" -DestinationPath "dependency-check" -Force
            
            # Create reports directory
            New-Item -ItemType Directory -Path "./security-reports" -Force
            
            # Run dependency check
            & "./dependency-check/bin/dependency-check.bat" --project "GCFoundation" --scan . --format ALL --out ./security-reports --suppression ./security-reports/suppressions.xml --enableExperimental
            
            Write-Host "‚úÖ OWASP Dependency Check completed" -ForegroundColor Green
          } catch {
            Write-Host "‚ö†Ô∏è OWASP Dependency Check failed: $_" -ForegroundColor Red
          }

    # Enhanced Vulnerability Scanning
    - task: PowerShell@2
      displayName: 'Enhanced Vulnerability Scanning'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "## Enhanced Vulnerability Scanning" -ForegroundColor Cyan
          Write-Host "=================================" -ForegroundColor Cyan
          
          $vulnerabilities = @()
          
          # Check for vulnerable packages using .NET CLI
          Write-Host "Checking for vulnerable NuGet packages..." -ForegroundColor Yellow
          try {
            $vulnerableOutput = dotnet list package --vulnerable 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "‚úÖ No vulnerable packages found" -ForegroundColor Green
            } else {
              Write-Host "‚ö†Ô∏è Vulnerable packages detected:" -ForegroundColor Red
              Write-Host $vulnerableOutput -ForegroundColor Red
              $vulnerabilities += "Vulnerable NuGet packages found"
            }
          } catch {
            Write-Host "‚ö†Ô∏è Vulnerability check not available" -ForegroundColor Yellow
          }
          
          # Check for outdated packages
          Write-Host "`nChecking for outdated packages..." -ForegroundColor Yellow
          try {
            $outdatedOutput = dotnet list package --outdated 2>&1
            if ($LASTEXITCODE -ne 0) {
              Write-Host "‚ö†Ô∏è Outdated packages detected:" -ForegroundColor Yellow
              Write-Host $outdatedOutput -ForegroundColor Yellow
            } else {
              Write-Host "‚úÖ All packages are up to date" -ForegroundColor Green
            }
          } catch {
            Write-Host "‚ö†Ô∏è Outdated package check not available" -ForegroundColor Yellow
          }
          
          # Check for high-risk dependencies
          Write-Host "`nScanning for high-risk dependency patterns..." -ForegroundColor Yellow
          $riskPatterns = @(
            "System.Web.Mvc.*[0-4]\.",
            "Newtonsoft.Json.*[0-9]\.",
            "jQuery.*[1-2]\.",
            "Microsoft.AspNetCore.*[1-2]\."
          )
          
          foreach ($pattern in $riskPatterns) {
            $matches = Get-ChildItem -Path . -Filter "*.csproj" -Recurse | 
              Select-String -Pattern $pattern
            if ($matches) {
              $vulnerabilities += "High-risk dependency pattern: $pattern"
              Write-Host "‚ö†Ô∏è Found high-risk dependency: $pattern" -ForegroundColor Red
            }
          }
          
          # Export vulnerability report
          if ($vulnerabilities.Count -gt 0) {
            $vulnerabilities | Out-File "security-reports/vulnerability-summary.txt"
            Write-Host "`nüìã Vulnerability Summary:" -ForegroundColor Red
            $vulnerabilities | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
          } else {
            Write-Host "`n‚úÖ No major vulnerabilities detected" -ForegroundColor Green
          }

    - task: PowerShell@2
      displayName: 'Advanced Code Security Analysis'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "## Advanced Code Security Analysis" -ForegroundColor Cyan
          Write-Host "=================================" -ForegroundColor Cyan
          
          $securityIssues = @()
          
          # Enhanced hardcoded secrets detection
          Write-Host "Scanning for hardcoded secrets..." -ForegroundColor Yellow
          $secretPatterns = @(
            "(password|pwd|secret|key|token|api[_-]?key|auth[_-]?token)[\s]*[=:][\s]*[`"'][^`"']{8,}[`"']",
            "connectionstring[\s]*[=:][\s]*[`"'][^`"']+[`"']",
            "[A-Za-z0-9+/]{40,}={0,2}",  # Base64 patterns
            "[0-9a-fA-F]{32,64}"          # Hex patterns
          )
          
          foreach ($pattern in $secretPatterns) {
            $matches = Get-ChildItem -Path . -Filter "*.cs" -Recurse | 
              Select-String -Pattern $pattern -CaseSensitive:$false
            if ($matches) {
              $securityIssues += "Potential hardcoded secrets found"
              Write-Host "‚ö†Ô∏è Found potential secrets (pattern: $pattern)" -ForegroundColor Red
              $matches | ForEach-Object { Write-Host "  $($_.Filename):$($_.LineNumber)" -ForegroundColor Red }
            }
          }
          
          # SQL injection patterns
          Write-Host "Scanning for SQL injection vulnerabilities..." -ForegroundColor Yellow
          $sqlPatterns = @(
            'SqlCommand.*[\+\$].*Request',
            'CommandText.*[\+\$].*Request',
            'ExecuteNonQuery.*[\+\$]',
            'ExecuteScalar.*[\+\$]'
          )
          
          foreach ($pattern in $sqlPatterns) {
            $matches = Get-ChildItem -Path . -Filter "*.cs" -Recurse | 
              Select-String -Pattern $pattern -CaseSensitive:$false
            if ($matches) {
              $securityIssues += "Potential SQL injection vulnerabilities found"
              Write-Host "‚ö†Ô∏è Found potential SQL injection (pattern: $pattern)" -ForegroundColor Red
              $matches | ForEach-Object { Write-Host "  $($_.Filename):$($_.LineNumber)" -ForegroundColor Red }
            }
          }
          
          # XSS and unsafe output patterns
          Write-Host "Scanning for XSS vulnerabilities..." -ForegroundColor Yellow
          $xssPatterns = @(
            'Response\.Write.*Request',
            'Html\.Raw.*Request',
            '@Request\[',
            'innerHTML.*Request'
          )
          
          foreach ($pattern in $xssPatterns) {
            $matches = Get-ChildItem -Path . -Filter "*.cs" -Recurse | 
              Select-String -Pattern $pattern -CaseSensitive:$false
            if ($matches) {
              $securityIssues += "Potential XSS vulnerabilities found"
              Write-Host "‚ö†Ô∏è Found potential XSS (pattern: $pattern)" -ForegroundColor Red
              $matches | ForEach-Object { Write-Host "  $($_.Filename):$($_.LineNumber)" -ForegroundColor Red }
            }
          }
          
          # Insecure deserialization patterns
          Write-Host "Scanning for insecure deserialization..." -ForegroundColor Yellow
          $deserializationPatterns = @(
            'BinaryFormatter',
            'JavaScriptSerializer',
            'DataContractJsonSerializer.*UntrustedData'
          )
          
          foreach ($pattern in $deserializationPatterns) {
            $matches = Get-ChildItem -Path . -Filter "*.cs" -Recurse | 
              Select-String -Pattern $pattern -CaseSensitive:$false
            if ($matches) {
              $securityIssues += "Insecure deserialization patterns found"
              Write-Host "‚ö†Ô∏è Found insecure deserialization (pattern: $pattern)" -ForegroundColor Red
              $matches | ForEach-Object { Write-Host "  $($_.Filename):$($_.LineNumber)" -ForegroundColor Red }
            }
          }
          
          # Save security analysis report
          if ($securityIssues.Count -gt 0) {
            $securityIssues | Out-File "security-reports/code-security-issues.txt"
            Write-Host "`nüìã Security Issues Summary:" -ForegroundColor Red
            $securityIssues | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
          } else {
            Write-Host "`n‚úÖ No obvious security issues detected in code" -ForegroundColor Green
          }

    # Publish security reports
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Security Reports'
      condition: always()
      inputs:
        pathToPublish: 'security-reports'
        artifactName: 'security-reports'
        artifactType: 'container'

- stage: Package
  displayName: 'Package and Publish'
  dependsOn: [Build, Security]
  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
  jobs:
  - job: PublishPackages
    displayName: 'Publish NuGet Packages'
    steps:
    # Download artifacts from all build jobs
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Build Artifacts'
      inputs:
        buildType: 'current'
        downloadType: 'specific'
        itemPattern: '**/*.nupkg'
        downloadPath: '$(System.ArtifactsDirectory)'

    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'

    - task: NuGetCommand@2
      displayName: 'Push NuGet Packages to Azure Artifacts'
      inputs:
        command: 'push'
        publishVstsFeed: '$(nugetSource)'
        searchPatternPush: '$(System.ArtifactsDirectory)/**/*.nupkg'
        allowPackageConflicts: true

    # Generate deployment summary
    - task: PowerShell@2
      displayName: 'Generate Deployment Summary'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "## Deployment Summary" -ForegroundColor Green
          Write-Host "=====================" -ForegroundColor Green
          Write-Host ""
          Write-Host "üì¶ Packages Published:" -ForegroundColor Cyan
          Get-ChildItem -Path "$(System.ArtifactsDirectory)" -Filter "*.nupkg" -Recurse | 
            ForEach-Object { Write-Host "  ‚úÖ $($_.Name)" -ForegroundColor Green }
          Write-Host ""
          Write-Host "üîó Feed: $(nugetSource)" -ForegroundColor Yellow
          Write-Host "üìÖ Published: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -ForegroundColor Yellow
          Write-Host "üè∑Ô∏è Version: $(Build.BuildNumber)" -ForegroundColor Yellow
